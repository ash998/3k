#class {botcycle_vars} {open};

#nop class <classname> read implicitely closes the class;
#class botcycle_vars read {.tt/3k/vars/botcycle.var};

#class {botcycle_vars} {open};

#if {!&multicycle} {
        #var multicycle {};
        #class botcycle_vars write {.tt/3k/vars/botcycle.var};
};

#if {!&multicycle} {
	#var multicycle {};
};


tthelp_add dscaler Usage: dscaler <dungeon> <scaler>;
#alias {dscaler} {

  #var _dungeon {_noval};
  #var _scaler {_noval};
  #regex {%0} {{^(.+) (.+)$}}
  {
    #var _dungeon {&2};
    #var _scaler {&3};
                   
  };

  #if {"$_dungeon"=="_noval" || "$_scaler"=="_noval"} {
    #showme Usage: dscaler <dungeon> <scaler>;
    #showme Note that this setting is per char per guild.;
    #foreach {*dungeon[scaler][]} {item} {
      #if {$dungeon[scaler][$item][$world][$guild]} {
        #show For $world in the $guild guild $item is scaled to $dungeon[scaler][$item][$world][$guild];
      };
    };
  } {
    #var dungeon[scaler][$_dungeon][$world][$guild] {$_scaler};
    #showme The scaler for the $_dungeon dungeon, for $world as $guild, is now set to $_scaler.;
    #class botcycle_vars write {.tt/3k/vars/botcycle.var};
    #showme Scaler data saved to .tt/3k/vars/botcycle.var;
  };
};

#alias {_initialize_multicycle} {
        #if {"@guild_cycletype{}"!="\@guild_cycletype\{\}" && "@guild_cycletype{}"!=="$multicycle[$world][$guild][current]"} {
		#class {botcycle_vars} {open};
                #var multicycle[$world][$guild][current] {@guild_cycletype{}};
		#class botcycle_vars write {.tt/3k/vars/botcycle.var};
		#class {botcycle_vars} {close};
        };

	#if {$multicycle[$world][$guild][type]} {
		#var _savedbotstatedetected {0};
	        #foreach {*multicycle[$world][$guild][type][]} {cycletype} {
			#if {$multicycle[$world][$guild][type][$cycletype][savedbotstate][position]} {
				#var _savedbotstatedetected {1};
			};
		};
		#if {$_savedbotstatedetected} {
			#showme NOTE: saved bot states exist!;
			#showme To continue with the saved bot states use "gogo continue".;
			#showme To start the cycle from scratch (starting with the @cycletype{} cycle) use "gogo clean".;
			#showme To start over, use "botclear" and make your setup from scratch, then start it with "gogo clean".;
		};
	};
	botdraw;
};

#event {VARIABLE UPDATE multicycle} {
#nop	#delay 0 botdraw;
#nop	#class botcycle_vars write {.tt/3k/vars/botcycle.var};
#nop	#showme Data saved to .tt/3k/vars/botcycle.var;
};


#class {botcycle_vars} {close};


#nop This file loads before $guild is set, so wait a second before setting up.
#delay {1} {_initialize_multicycle};

#class {botcycle} {open};
#NOP REQUIRED:  draw.tin  //canvas dimensions;
#nop		bot_main.tin;
#nop		The $world and $guild vars must be set;

tthelp_add gogo Usage: gogo clean to run everything from scratch, gogo continue to run from where you were at.;
#alias {gogo} {
        #if {"@guild_cycletype{}"!="\@guild_cycletype\{\}" && "@guild_cycletype{}"!="$multicycle[$world][$guild][current]"} {
                #var multicycle[$world][$guild][current] {@guild_cycletype{}};
        };

	#if {"%1"!="clean" && "%1"!="continue"} {
		#show Use gogo clean to clear saved states and start from scratch.;
		#show Use gogo continue to continue running from previously saved state.;
	} {
		#if {"%1"=="clean"} {
		        #foreach {*multicycle[$world][$guild][type][]} {cycletype} {
		                #unvar multicycle[$world][$guild][type][$cycletype][savedbotstate];
				#var multicycle[$world][$guild][type][$cycletype][cycle] 1;
			};
			cycle 1;
			save_botcycle;
			thisarea;
		};
		#if {"%1"=="continue"} {
			_cycleload @cycletype{};
		};
        };
	botdraw;
	save_botcycle;
};


#alias {save_botcycle} {
	#class botcycle_vars write {.tt/3k/vars/botcycle.var};
};


#function {cycletype} {
	#return $multicycle[$world][$guild][current];
};


#alias {cycleadd} {
	#var cycle_already_exists {0};
	#foreach {*multicycle[$world][$guild][type]} {curtype} {
		#if {"$multicycle[$world][$guild][type][$curtype]"=="%0"} {
			#var cycle_already_exists {1};
			#break;
		};
	};
	#if {$cycle_already_exists==0} {
		#list {multicycle[$world][$guild][type]} {add} {%0};
		botdraw;
		save_botcycle;
	};
	#else {#show The %0 cycle already exists.;};
};

#alias {cycledel} {
	#if {"$multicycle[$world][$guild][type][%0]"!=""} {
		#unvar multicycle[$world][$guild][type][%0];
		botdraw;
		save_botcycle;
	};
	#else {#show The %0 cycle does not exists, nothing was deleted.;};
};

tthelp_add ba Usage: ba <stepper path> [cycle type];
#alias {ba} {
	#if {"$multicycle[$world][$guild][type][%2]"!=""} {
		#if {"%2"==""}	{#var cycletype {default}}
				{#var cycletype {%2}};
		#var botpath {%1};
	        #if {!$multicycle[$world][$guild][type][$cycletype][cycle]} {#var multicycle[$world][$guild][type][$cycletype][cycle] 1};
	        #list {multicycle[$world][$guild][type][$cycletype][botcycle]} {add} {%1};
		save_botcycle;
	        botdraw;
	};
	#else {#show The %0 cycle does not exists, nothing was added.;};
};

tthelp_add br Usage: br <cycle number> [cycle type];
#alias {br} {
	#if {"$multicycle[$world][$guild][type][%2]"!=""} {
	        #if {"%2"==""}	{#var cycletype {default}}
				{#var cycletype {%2}};

		#var cyclenum {%1};

		#list {multicycle[$world][$guild][type][$cycletype][botcycle]} {del} {$cyclenum};

		#if {$cyclenum == $multicycle[$world][$guild][type][$cycletype][cycle]} {
			#nop If we're deleting the saved cycle, zero out the saved cycle;
			#unvar multicycle[$world][$guild][type][$cycletype][savedbotstate];
		};

		#if {$cyclenum < $multicycle[$world][$guild][type][$cycletype][cycle]} {
			#math {multicycle[$world][$guild][type][$cycletype][cycle]} {$multicycle[$world][$guild][type][$cycletype][cycle] - 1};
		};
		save_botcycle;
		botdraw;
	};
	#else {#show The %0 cycle does not exists, nothing was removed.;};
};

tthelp_add botclear Usage: botclear. Will clear everything from the cycler so you can start from scratch.;
#alias {botclear} {
	#foreach {*multicycle[$world][$guild][type][]} {cycletype} {
		#var multicycle[$world][$guild][type][$cycletype][cycle] {0};
		#var multicycle[$world][$guild][type][$cycletype][botcycle] {};
		#var bots[position] {0};
		#unvar multicycle[$world][$guild][type][$cycletype][savedbotstate];
	};
	save_botcycle;
	botdraw;
};

#alias {tester} {
	#local room_to_go_to %1;
	#map list {{roomnote} {$room_to_go_to%*} {variable} {_room_info}};
	#foreach {*_room_info[]} {_room_vnum} {
		#map get {roomname} {_room_name} {$_room_vnum};
		#break;
	};
	#showme $_room_name;
};


tthelp_add thisarea Usage: thisarea. Will load the current area from the current cycle and start running the bot in it.;
#alias {thisarea} {
#show CALLED: thisarea;
	#list {multicycle[$world][$guild][type][@cycletype{}][botcycle]} {get} {$multicycle[$world][$guild][type][@cycletype{}][cycle]} {multicycle[$world][$guild][type][@cycletype{}][currentarea]};

	#if {$dungeon[scaler][$multicycle[$world][$guild][type][@cycletype{}][currentarea]][$world][$guild]} {scaler $dungeon[scaler][$multicycle[$world][$guild][type][@cycletype{}][currentarea]][$world][$guild]};

	#var roomnote {};
	#var roomtrigger {};

	#read .tt/3k/bots/$multicycle[$world][$guild][type][@cycletype{}][currentarea].tin;

	#if {"$roomnote"!=""} {
		#local room_to_go_to $roomnote;
	} {
		#local room_to_go_to $multicycle[$world][$guild][type][@cycletype{}][currentarea];
	};

	go $room_to_go_to;

	#if {"$roomtrigger"!=""} {
		#var _roomtrigger {$roomtrigger};
	} {
#nop Find the room name from the map;
		#map list {{roomnote} {$room_to_go_to%*} {variable} {_room_info}};
		#foreach {*_room_info[]} {_room_vnum} {
			#map get {roomname} {_room_name} {$_room_vnum};
			#break;
		};
#nop Remove any trailing exits in the room because they can come in any order;
		#regex {$_room_name} {{(.*)( \(.*?\)$)}} {
			#var _roomtrigger {&2};
		} { 
			#regex {$_room_name} {{(.*)$}} {
				#var _roomtrigger {&2};
			}
		};
	};

	#unvar multicycle[$world][$guild][type][@cycletype{}][savedbotstate];

	#class {botcycle_room_trigger} {open};
	#act {{\Q$_roomtrigger\E}} {
		- $multicycle[$world][$guild][type][@cycletype{}][currentarea];
		#delay {1} {..};
		#class {botcycle_room_trigger} {kill};
		
	} {1};
	#class {botcycle_room_trigger} {close};

#nop        #delay {4} {..};
	botdraw;
	save_botcycle;
};


tthelp_add nextarea Usage: nextarea. Will load the next area from the current cycle and start running the bot in it.;
#alias {nextarea} {
#show CALLED: nextarea;
	#if {$multicycle[$world][$guild][type][@cycletype{}][cycle] < &{multicycle[$world][$guild][type][@cycletype{}][botcycle][]}} {
			#math multicycle[$world][$guild][type][@cycletype{}][cycle] {$multicycle[$world][$guild][type][@cycletype{}][cycle]+1}
	} {
			#var multicycle[$world][$guild][type][@cycletype{}][cycle] 1
	};

	#list {multicycle[$world][$guild][type][@cycletype{}][botcycle]} {get} {$multicycle[$world][$guild][type][@cycletype{}][cycle]} {multicycle[$world][$guild][type][@cycletype{}][currentarea]};

	#if {$dungeon[scaler][$multicycle[$world][$guild][type][@cycletype{}][currentarea]][$world][$guild]} {scaler $dungeon[scaler][$multicycle[$world][$guild][type][@cycletype{}][currentarea]][$world][$guild]};

	#var roomnote {};
	#var roomtrigger {};

	#read .tt/3k/bots/$multicycle[$world][$guild][type][@cycletype{}][currentarea].tin;

	#if {"$roomnote"!=""} {
		#local room_to_go_to $roomnote;
	} {
		#local room_to_go_to $multicycle[$world][$guild][type][@cycletype{}][currentarea];
	};

	go $room_to_go_to;

	#if {"$roomtrigger"!=""} {
		#var _roomtrigger {$roomtrigger};
	} {
#nop Find the room name from the map;
		#map list {{roomnote} {$room_to_go_to%*} {variable} {_room_info}};
		#foreach {*_room_info[]} {_room_vnum} {
			#map get {roomname} {_room_name} {$_room_vnum};
			#break;
		};
#nop Remove any trailing exits in the room because they can come in any order;
		#regex {$_room_name} {{(.*)( \(.*?\)$)}} {
			#var _roomtrigger {&2};
		} { 
			#regex {$_room_name} {{(.*)$}} {
				#var _roomtrigger {&2};
			}
		};
	};

	#unvar multicycle[$world][$guild][type][@cycletype{}][savedbotstate];
#nop #SHORTEST PATH: Already there.;
	#class {botcycle_room_trigger} {open};
	#act {{\Q$_roomtrigger\E}} {
		- $multicycle[$world][$guild][type][@cycletype{}][currentarea];
		#delay {1} {..};
		#class {botcycle_room_trigger} {kill};
	} {1};
	#class {botcycle_room_trigger} {close};

#nop        #delay {4} {..};
	botdraw;
	save_botcycle;
};

tthelp_add cyclesave Usage: don't use this, it's an internal alias.;
#nop Save the state of the current bot, so we can get back to it easily;
#alias {cyclesave} {
#show CALLED: cyclesave;
        #map get {roomvnum} {bots[vnum]};
        #path save forward bots[path];
        #path save position bots[position];


	#var multicycle[$world][$guild][type][$multicycle[$world][$guild][current]][savedbotstate][length] $bots[length];
        #var multicycle[$world][$guild][type][$multicycle[$world][$guild][current]][savedbotstate][path] $bots[path];
        #var multicycle[$world][$guild][type][$multicycle[$world][$guild][current]][savedbotstate][position] $bots[position];
        #var multicycle[$world][$guild][type][$multicycle[$world][$guild][current]][savedbotstate][stepper] $bots[stepper];
        #var multicycle[$world][$guild][type][$multicycle[$world][$guild][current]][savedbotstate][vnum] $bots[vnum];
        #class botcycle_vars write {.tt/3k/vars/botcycle.var};
};

tthelp_add _cycleload Usage: don't use this, it's an internal alias.;
#alias {_cycleload} {
#show CALLED: _cycleload, PARAMETER: %1;
	#if {""!=="$multicycle[$world][$guild][type][%1][savedbotstate][length]"} {
#show DEBUG: _cycleload #IF statment is true. Position: $multicycle[$world][$guild][type][%1][savedbotstate][length];
                - $multicycle[$world][$guild][type][%1][savedbotstate][stepper];
                #var bots[length] $multicycle[$world][$guild][type][%1][savedbotstate][length];
                #var bots[path] $multicycle[$world][$guild][type][%1][savedbotstate][path];
                #var bots[position] $multicycle[$world][$guild][type][%1][savedbotstate][position];
                #var bots[stepper] $multicycle[$world][$guild][type][%1][savedbotstate][stepper];
                #var bots[vnum] $multicycle[$world][$guild][type][%1][savedbotstate][vnum];
                .resume;
        } {
#show DEBUG: _cycleload #IF statment is false;
                cycle 1;
                thisarea;
        };
	botdraw;
};

tthelp_add cycleload Usage: don't use this, it's an internal alias.;
#nop Save the state of the current bot and load the state of the specified bot;
#alias {cycleload} {
#show CALLED: cycleload, PARAMETER: %1;
	#if {@numbotareas{%1}} {
		cyclesave;
		#var multicycle[$world][$guild][current] {%1};

		_cycleload %1;
	} {
		#showme Attempted to load empty or nonexisting cycle type "%1", load aborted.;
	};
        #class botcycle_vars write {.tt/3k/vars/botcycle.var};
};

tthelp_add bc Usage: bc [cycle type]. Shows the paths loaded into the cycle type or the current cycle type if no type is given.;
#alias {bc} {
	#if {"%1"==""} {
		#var cty {@cycletype{}};
	} {
		#var cty {%1};
	};

        #echo {<228>+-------------------+}<088>;

	#if {"$cty"!=""} {#format {header_display} {%-17s} {$cty}} {#format {header_display} {%-17s} {Area Cycler}};
        #echo {<228>|<138> $header_display <228>|<088>};
        #echo {<228>+-------------------+}<088>;
        #if {&{multicycle[$world][$guild][type][$cty][botcycle][]} == 0} {
                #echo {<228> |<178>  No areas loaded  <228>|<088>};
                #echo {<228> +-------------------+}<088>
        } {
                #var cnt 0;
                #while {$cnt < &{multicycle[$world][$guild][type][$cty][botcycle][]}} {
                        #math {cnt} {$cnt + 1};
                        #if {$cnt == $multicycle[$world][$guild][type][$cty][cycle]} {
                                #format {cntnum} {%+4s} {<128>$cnt\.<088>};
                                #format {area_display} {%-13s} {<128>$multicycle[$world][$guild][type][$cty][botcycle][$cnt]<088>}
                        } {
                                #format {cntnum} {%+4s} {<178>$cnt\.<088>};
                                #format {area_display} {%-13s} {<148>$multicycle[$world][$guild][type][$cty][botcycle][$cnt]<088>}
                        };
                        #echo { <228>| $cntnum $area_display <228>|<088>};
                };
                #echo { <228>+-------------------+}<088>
        }
};

#function {numbotareas} {
	#if {"%1"!=""} {
		#return {&{multicycle[$world][$guild][type][%1][botcycle][]}};
	} {
		#return {&{multicycle[$world][$guild][type][@cycletype{}][botcycle][]}};
	};
};

#function {_botdraw} {

	#regex {%0} {{^(.+) (.+)$}}
	{
		#var cty {&2};
		#var drawoffset {&3};
	};

        #if {"$cty"==""} {
                #var cty {@cycletype{}};
        };

	#if {"$drawoffset"==""} {
		#var drawoffset {0};
	};

	#if {"$multicycle[$world][$guild][type][$cty][savedbotstate][position]"!=""} {
		#var progress { ($multicycle[$world][$guild][type][$cty][savedbotstate][position]/$multicycle[$world][$guild][type][$cty][savedbotstate][length])};
	} {
		#var progress {};
	};


	#var botheight {0};
	#var _numbotareas {&{multicycle[$world][$guild][type][$cty][botcycle][]}};

        #if {"$draw[canvas]" == "on"} {
	        #NOP Clear previous drawing;
		#if {!$drawoffset} {
		        #screen clear square $map[height]+$caption[height]+1 -$canvas[width]+1 -$status[height]-2 -1;
		};

	        #if {!$_numbotareas} {
			#format {area_display} {%-17s} {No areas in: $cty};
                	#var botareas {
	                        <178>$area_display<088>
		        };
	                #var botheight 1;
	        } {
	                #var botheight {$_numbotareas};
	                #var botareas {};
	                #var cnt 0;
	                #while {$cnt < $_numbotareas} {
	                        #math {cnt} {$cnt + 1};
	                        #if {$cnt == $multicycle[$world][$guild][type][$cty][cycle]} {
	                                #format {cntnum} {%+4s} {<128>$cnt.<088>};
					#format {area_display} {%-12s} {<128>$multicycle[$world][$guild][type][$cty][botcycle][$cnt]$progress<088>};
	                        } {
	                                #format {cntnum} {%+4s} {<178>$cnt.<088>};
	                                #format {area_display} {%-12s} {<148>$multicycle[$world][$guild][type][$cty][botcycle][$cnt]<088>};
		                };
	                        #if {$cnt == 1} {
	                                #var botareas {$cntnum $area_display};
	                        } {
	                                #var botareas {$botareas\n$cntnum $area_display};
	                        };
	                };
	        };
		#format {area_display} {%-17s} {Areas in: $cty};
	        #draw green rounded box $map[height]+$caption[height]+2+$drawoffset -$canvas[width]+2 $map[height]+$caption[height]+4+$drawoffset -3 {
	                <138>$area_display<088>
	        };
	        #draw green rounded box $map[height]+$caption[height]+4+$drawoffset -$canvas[width]+2 $map[height]+$caption[height]+5+$botheight+$drawoffset -3 {
	                $botareas
	        };
	        #showme {<228>\u251C} $map[height]+$caption[height]+4+$drawoffset -$canvas[width]+2;
	        #showme {<228>\u2524} $map[height]+$caption[height]+4+$drawoffset -3;
        };
	#return @math{$drawoffset+$botheight+4};
};

tthelp_add botdraw Usage: botdraw. Will update the info on the lower right pane.
#alias {botdraw} {
	#var _drawoffset {@_botdraw{@cycletype{} 0}};

        #foreach {*multicycle[$world][$guild][type][]} {cycletype} {
		#if {"@cycletype{}"!="$cycletype"} {
			#var _drawoffset @_botdraw{$cycletype $_drawoffset};
		}
        };

};
tthelp_add cycle Usage: cycle <cycle number> [cycle type]. Will set the cycle in the cycle type (or current if omitted) to the cycle number.;
#alias {cycle} {
        #if {"%2"===""}  {#var cycletype {@cycletype{}}}
                         {#var cycletype {%2}};

        #var multicycle[$world][$guild][type][$cycletype][cycle] {%1};
	#unvar multicycle[$world][$guild][type][$cycletype][savedbotstate];
	#list {multicycle[$world][$guild][type][$cycletype][botcycle]} {get} {$multicycle[$world][$guild][type][$cycletype][cycle]} {multicycle[$world][$guild][type][$cycletype][currentarea]};
	botdraw;
	save_botcycle;
};
tthelp_add setcycletype Usage: internal alias, don't use it.;
#alias {setcycletype} {
        #var multicycle[$world][$guild][current] {%1};
	botdraw;
	save_botcycle;
};


#alias {bas}		{ba {rim2;android;dundee8;dundee7;dundee6;dundee5}};
#NOP #alias {bas2}	{ba {whorehouse;puppy;mahjongg;rim2;whorehouse;puppy;mahjongg;android;whorehouse;puppy;mahjongg;rim2;whorehouse;puppy;mahjongg;dundee8;whorehouse;puppy;mahjongg;rim2;whorehouse;puppy;mahjongg;dundee7;whorehouse;puppy;mahjongg;rim2;whorehouse;puppy;mahjongg;dundee6}};
#alias {bas2}		{ba {whorehouse;mahjongg;rim2;whorehouse;mahjongg;dundee8;whorehouse;mahjongg;dundee7;whorehouse;mahjongg;dundee6}};
#alias {bas3}		{ba {whorehouse;rim2;whorehouse;dundee8;whorehouse;dundee7;whorehouse;dundee6}};
#alias {basa}		{ba {aegis1;aegis2;aegis3;aegis4;aegis5}};
#alias {badundee}	{ba {dundee1;dundee2;dundee3;dundee4;dundee5;dundee6;dundee7;dundee8}};
#alias {bao}            {ba {chess;zelligars;chess;mahjongg;chess;mahjongg}};

#class {botcycle} {close}
