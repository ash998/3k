#if {!@file_exists{.tt/3k/vars/bard.var}}
{
	#class {bard_vars} {open};

	#var bardv[cycle][type] {default};


#nop When down to this many corpses, switch to gather cycle type;
	#var bardv[cycle][min_corpses] {5};

#nop When up to this many corpses, switch to spend cycle type, set to 0 to use coffin max;
	#var bardv[cycle][max_corpses] {0};

	#class bard_vars write {.tt/3k/vars/bard.var};
	#class {bard_vars} {close};

}
{
  #class bard_vars read {.tt/3k/vars/bard.var};
};

#class {bard} {open}

#var guild bard;

#var bard[current_cycletype] {$bardv[cycle][type]};

#nop TODO: This variable needs to be set by something else;
#var bard[coffin][max] {25};

/* HP Bars */
#NOP bset custom_hp @hired:|@HP:&$HP2$& SP:&$SP2$& K:&$K2$& V:&$V2$& SM:&$S$&/&$SR$&% G:&$G2S$&/&$G2N$&[&$G2N%$&%] &$C$&&$NL$&@hired:|@A:&$AS$& &$P$&
#act {|HP:%d/%d SP:%d/%d K:%d/%d V:%d/%d SM:%d/%d%% G:%d/%d[%d%%]} {
	#var my[hp][current]		%2;
	#var my[hp][max]		%3;
	#var my[sp][current]		%4;
	#var my[sp][max]		%5;
	#var my[gp1][current]		%6;
	#var my[gp1][max]		%7;
	#var my[gp2][current]		%8;
	#var my[smiles][current]	%9;
	#var my[smiles][reset]		%10;
	#var my[gxp][current]		%11;
	#var my[gxp][max]		%12;
	#var my[gxp][per]		%13
};

#act {|A: [[ %* ]]} {
	update_status
};

#function {guild_halt} {
#nop No guild pauses implemented;
        #return  0;
};

#function {guild_cycletype} {
        #return $bard[current_cycletype];
};

#alias {bcycleset} {
        #if {"%1"!="default" && "%1"!="gather" && "%1"!="spend"} {
                #showme Usage: bcycleset [default|gather|spend];
                #showme        If using "default", it will stay in default untill you set it to something else.;
                #showme        If using "gather" or "spend", it will toggle between the two based on the values;
                #showme        in bardv[cycle][min_corpses] and bardv[cycle][max_corpses].;
                #showme        Your current cycle is: @guild_cycletype{};
        } {
                #var bard[current_cycletype] {%1};
                #var bardv[cycle][type] {%1};
		save_guild_vars;
        }
};

#alias {bcyclecheck} {
        #nop If we're in default, stay in default. Only swap between gather and spend.;
        #if {"$bard[current_cycletype]"!="default"} {

                #if {"$bard[current_cycletype]"=="gather"} {
                        #if {!$bardv[cycle][max_corpses]} {#var _max_corpses {$bard[coffin][max]}} {#var _max_corpses {$bardv[cycle][max_corpses]}};
                        #if {$corpses[coffin] >= $_max_corpses} {
                                #var bard[current_cycletype] {spend};
                                update_chat <138>Auto switching to spend cycle.<099>;
                        };
                } {
                        #if {$corpses[coffin] < $bardv[cycle][min_corpses]} {
                                #var bard[current_cycletype] {gather};
                                update_chat <138>Auto switching to gather cycle.<099>;
                        };
                };
        };
};

#alias {save_guild_vars} {#class bard_vars write {.tt/3k/vars/bard.var}};

#alias {update_status} {
	bcyclecheck;
	#if {"$cooler" == "on" || $corpses[cooler] > 0} {
			#format {sb1_cooler} {%+2s} {$corpses[cooler]};
			#var {sb1_cooler} { CL:<130>$sb1_cooler<088>}
	} {
			#var {sb1_cooler} {}
	};
	#if {"$freezer" == "on" || $corpses[freezer] > 0} {
			#format {sb2_freezer} {%+2s} {$corpses[freezer]};
			#var {sb2_freezer} { FZ:<130>$sb2_freezer<088>}
	} {
			#var {sb2_freezer} {}
	};
	#var {my[hp][graph]}    {@graph{$my[hp][current];${my[hp][max]}}};
	#var {my[gp1][graph]}   {@graph{$my[gp1][current];$my[gp1][max]}};
	#var {my[gp2][graph]}   {@graph{$my[gp2][current];$my[gp2][max]}};
	#var {my[gxp][graph]}	{@graph{$my[gxp][per];100}};
	#var {enemy[graph]}     {@graph{$enemy[hp];100}};
	#format {hp}            {%+4s} {@colscale{$my[hp][current];$my[hp][max]}};
	#format {hp_max}        {%+4s} {<128>$my[hp][max]<088>};
	#format {sp}		{%+4s} {@colscale{$my[sp][current];$my[sp][max]}};
	#format {sp_max}	{%+4s} {<128>$my[sp][max]<088>};
	#format {gp1}           {%+4s} {@colscale{$my[gp1][current];$my[gp1][max]}};
	#format {gp1_max}	{%+4s} {<128>$my[gp1][max]<088>};
	#format {gp2}           {%+3s} {@colscale{$my[gp2][current];$my[gp2][max]}};
	#format {ehealth}       {%+6s} {@colscale{$enemy[hp];100}};
	#format {gxp_col}       {%+5s} {@colscale{$my[gxp][per];100}};
	#format {corpses[inventory]}     {%+2s} {$corpses[inventory]};
	#format {corpses[coffin]}  {%+2s} {$corpses[coffin]};
	#format {corpses[freezer]} {%+2s} {$corpses[freezer]};
	#if {"$draw[hpbar]" == "on"} {
		#showme {<088>HP:$hp/$hp_max SP:$sp/$sp_max K:$gp1/$gp1_max  V:   $gp2\%    G: $gxp_col\%    E:$ehealth\%    IC:<130>${corpses[inventory]}<088> ${sb1_cooler}} {-4};
		#showme {H:${my[hp][graph]} S:${my[sp][graph]} K:${my[gp1][graph]} V:${my[gp2][graph]} G:${gxp_graph} E:${enemy[graph]} CF:<130>${corpses[coffin]}<088>${sb2_freezer}} {-3};
	};
	#if {"$draw[gline]" == "on"} {
		#showme {$mip[gline][1]  $mip[gline][2]} {-6};
	};
}

#alias {corpsetrig} {
#nop	#send {!wrap};
#nop	#send {!get all};
}

#class {bard} {close}
