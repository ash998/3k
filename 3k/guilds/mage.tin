#class {mage_vars} {open}
#var magev[auto][S] {0};
#var magev[auto][A] {1};
#var magev[auto][PE] {0};
#var magev[auto][PG] {1};
#var magev[auto][mg] {0};
#var magev[auto][MG] {1};
#var magev[auto][SS] {1};
#var magev[auto][B] {1};
#var magev[auto][DS] {0};
#var magev[auto][MB] {0};
#var magev[auto][b] {0};
#var magev[auto][PA] {1};
#var magev[auto][MI] {0};
#var magev[auto][I] {0};
#var magev[auto][MS] {1};
#var magev[auto][PS] {0};
#var magev[auto][M] {0};
#var magev[auto][L] {0};
#var magev[auto][<P>] {0};
#var magev[auto][min_mc] {85};
#var magev[auto][min_sp] {3000};
#var magev[auto][max_sat] {95};   
#var magev[auto][mystic_immersion_at] {4000};
#var magev[auto][explosive_release_at] {80};
#var magev[auto][spell_tap] {0};

#nop How much more SP after 90 rounds of MI than before
#var magev[setting][SPDeltaPerMI] {6000};

#nop How much SP spend per rnd avg. Doesn't have to be very accurate, it will even out towards the end of the MI cycle anyway.
#var magev[setting][SPSpentPerRnd] {30};

#var magev[setting][MaxSatToSpellTapAt] {85};

#class mage_vars read {.tt/3k/vars/mage.var};
#class {mage_vars} {close}

#class {mage} {open}

#var guild mage
#var mage[affect][S] {shield};
#var mage[affect][A] {armor};
#var mage[affect][PE] {protection from evil};
#var mage[affect][PG] {protection from good};
#var mage[affect][mg] {minor globe};
#var mage[affect][MG] {major globe};
#var mage[affect][SS] {stoneskin};
#var mage[affect][B] {blink};
#var mage[affect][DS] {detect scrying};
#var mage[affect][MB] {mind blank};
#var mage[affect][b] {blur};
#var mage[affect][PA] {prismatic aura};
#var mage[affect][MI] {mirror image};
#var mage[affect][I] {invisibility};
#var mage[affect][MS] {magnificent shield};
#var mage[affect][PS] {prismatic sphere};
#var mage[affect][M] {mantle};
#var mage[affect][L] {levitate};
#var mage[affect][<P>] {perform};

#var mage[gem_fetching] {0};
#var mage[buffer_explosive_release] {0};

#var mage[downtime][mental_cognition] {0};
#var mage[downtime][spell_points] {0};
#var mage[downtime][saturation] {0};
#var mage[info][SPDeficit] {0};
#var mage[info][incombat] {0};

#alias {spell_tap_automation} {

#nop How many rounds left in this reset with no MI running;
    #math {MIFreeRounds} {((100-$my[golem][reset])*6 - ($my[immersion][count]*90 + $my[immersion][rounds]))};

#nop How much SP we need to cover with tap to stay at 90% SP;
    #math {mage[info][SPDeficit]} {(($MIFreeRounds * $magev[setting][SPSpentPerRnd]) - ($my[immersion][count] * $magev[setting][SPDeltaPerMI]) + (($my[sp][max] * 9 / 10)-$my[sp][current]) - (($magev[setting][SPDeltaPerMI]*$my[immersion][rounds])/90))};

#nop    #show Deficit: $mage[info][SPDeficit] No MI rnds: $MIFreeRounds;

  #if {$magev[auto][spell_tap]}
  { 
    #math {SPToTapAt} {$my[sp][max]-500};
    #if {!$my[immersion][rounds] && $my[gp1][current]<$magev[setting][MaxSatToSpellTapAt] && $mage[info][SPDeficit]>0 && $my[sp][current]<$SPToTapAt}
    {
      cast spell tap
    };
  };
};


#nop #act {{^ HP: (\d+)/(\d+) SP: (\d+)/(\d+)}} {;

#act {^ HP: {\d+}/{\d+} SP: {\d+}/{\d+}{S|}/{\d+}%/{\d+}% Sat: {\d+} Cnc: {\d+} G/MI: {\d+}/{\d+}/{\d+}% ER: {\d+}/{\d+}% G2N: {\d+}%} {
	#var my[hp][current]	{%1};
	#var my[hp][max]	{%2};
	#var my[sp][current]    {%3};
	#var my[sp][max]        {%4};
#nop %5 is S if studying spellbook, otherwise blank. Not used;
        #var my[mental_cognition] {%6};
        #var my[gem]            {%7};
        #var my[gp1]            {%8};
        #var my[gp2]            {%9};
        #var my[golems]         {%10};
        #var my[immersion][count] {%11};
        #var my[golem][reset]   {%12};
        #var my[super][current] {%13};
        #var my[super][reset]   {%14};
        #var my[g2n]            {%15};


#nop Auto cast protection spells. Put them in priority order. Spamming in case there is lag.;
        #if {!$my[prots][SS] && $magev[auto][SS]} {cast $mage[affect][SS]};
        #if {!$my[prots][MG] && $magev[auto][MG]} {cast $mage[affect][MG]};
	#if {!$my[prots][PS] && $magev[auto][PS]} {cast $mage[affect][PS]};
	#if {!$my[prots][M] && $magev[auto][M]} {cast $mage[affect][M]};
	#if {!$my[prots][mg] && $magev[auto][mg]} {cast $mage[affect][mg]};
	#if {!$my[prots][B] && $magev[auto][B]} {cast $mage[affect][B]};
	#if {!$my[prots][MS] && $magev[auto][MS]} {cast $mage[affect][MS]};
	#if {!$my[prots][S] && $magev[auto][S]} {cast $mage[affect][S]};
	#if {!$my[prots][A] && $magev[auto][A]} {cast $mage[affect][A]};
	#if {!$my[prots][b] && $magev[auto][b]} {cast $mage[affect][b]};
	#if {!$my[prots][PG] && $magev[auto][PG]} {cast $mage[affect][PG]};
	#if {!$my[prots][PE] && $magev[auto][PE]} {cast $mage[affect][PE]};
	#if {!$my[prots][MI] && $magev[auto][MI]} {cast $mage[affect][MI]};
	#if {!$my[prots][I] && $magev[auto][I]} {cast $mage[affect][I]};
	#if {!$my[prots][PS] && $magev[auto][PS]} {cast $mage[affect][PS]};
	#if {!$my[prots][M] && $magev[auto][M]} {cast $mage[affect][M]};
	#if {!$my[prots][PA] && $magev[auto][PA]} {cast $mage[affect][PA]};
	#if {!$my[prots][MB] && $magev[auto][MB]} {cast $mage[affect][MB]};
	#if {!$my[prots][DS] && $magev[auto][DS]} {cast $mage[affect][DS]};
	#if {!$my[prots][L] && $magev[auto][L]} {cast $mage[affect][L]};
	
	#if {$my[gem]<80 && !$mage[gem_fetching]} {ffetch gem;#var mage[gem_fetching] {1};};


#nop Mystic Immersion;
#nop If it's not running, and there are more available and (sp is lower than the setup threshold OR it's at 98% or higher to reset) -> cast it.;
#nop Also setup vars if it was cast so spell tap automation knows the correct values.;
        #if {$my[immersion][rounds]==0 && $my[immersion][count]>0 && (($my[sp][current]<$magev[auto][mystic_immersion_at]) || $my[golem][reset]>97)} 
        {
                #math {my[immersion][count]} {$my[immersion][count]-1};
                #var my[immersion][rounds] {90};
                #var mage[downtime][spell_points] {0};
                cast mystic immersion
        }; 

        spell_tap_automation;

#nop Explosive Release;
        #if {!$mage[buffer_explosive_release] && $my[super][current] && (($my[gp1][current]>$magev[auto][explosive_release_at]) || ($my[gp1][current]>5 && $my[super][reset]>95))}
        {
           #var mage[buffer_explosive_release] {1};
           cast explosive release
        };

#nop If botting, add downtime based on various parameters;
        #if {$bot} {

#nop NOTE: $my[mental_cognition] is zero when at 100%;
#nop Mental Cognition;
            #if {$my[mental_cognition] && $my[mental_cognition]<$magev[auto][min_mc] && !$mage[downtime][mental_cognition]} {pause_bot;#var mage[downtime][mental_cognition] 1;#show !!!!!LOW MC BOT PAUSED!!!!!;};

#nop Spell Points;
            #if {$my[sp][current]<$magev[auto][min_sp] && !$mage[downtime][spell_points]} {pause_bot;#var mage[downtime][spell_points] 1;#show !!!!!LOW SP BOT PAUSED!!!!!;};

#nop Saturation;
            #if {$my[gp1][current]>$magev[auto][max_sat] && !$mage[downtime][saturation]} {pause_bot;#var mage[downtime][saturation] 1;#show !!!!!HIGH SAT BOT PAUSED!!!!!;};

        };
};

#alias {pause_bot} {
        #if {!$halt} {.tmp_pause}
};


#alias {unpause_bot} { 
        #if {!$halt} {#return};

        #var stay_paused 0;

        #nop Only unpause if all the things we're pausing for are fixed;
        
	#foreach {*mage[downtime][]} {item} {#if {$mage[downtime][$item]} {#var stay_paused 1}};
	
	#if {!$stay_paused} {.tmp_unpause}
};

#act {{^You raise your hands and focus your mind on the residual magical energy$}} {
  #var mage[buffer_explosive_release] {0};
};


#act {Xoox the fuzzy hedgehog hands something to Orthas.} {
    #if {"$world"=="orthas"} {
	#var mage[gem_fetching] {0};
    };
};

#act {A dark siamese cat hands something to Killergate.} {
    #if {"$world"=="killergate"} {
        #var mage[gem_fetching] {0};
    };
};


#act {Having absorbed all you can, you carefully close your spellbook.} 
{
        #if {$bot && $halt && $mage[downtime][mental_cognition]} {#var mage[downtime][mental_cognition] 0;unpause_bot}
};

#alias {update_status} {
        #if {"$enemy[hp]" == ""} {#var mage[info][incombat] {0}} {#var mage[info][incombat] {1}};

        #if {$bot} {
	    #if {$mage[downtime][spell_points] && $my[sp][current]==$my[sp][max]} {#var mage[downtime][spell_points] 0;unpause_bot};
            #if {$mage[downtime][saturation] && $my[gp1][current]==0} {#var mage[downtime][saturation] 0;unpause_bot};

            #if {$halt} {
                #var stay_paused 0;
                #nop Added this check because MI firing might have unpaused us;
                #foreach {*mage[downtime][]} {item} {#if {$mage[downtime][$item]} {#var stay_paused 1}};
                #if {!$stay_paused} {#var halt {0}};
            };


        };
        #if {"$cooler" == "on" || $corpses[cooler] > 0} {
                #format {sb1_cooler} {%+2s} {$corpses[cooler]};
                #var {sb1_cooler} { CL:<130>$sb1_cooler<088>}
        } {
                #var {sb1_cooler} {}
        };
        #if {"$freezer" == "on" || $corpses[freezer] > 0} {
                #format {sb2_freezer} {%+2s} {$corpses[freezer]};
                #var {sb2_freezer} { FZ:<130>$sb2_freezer<088>}
        } {
                #var {sb2_freezer} {}
        };
        #var {my[hp][graph]}    {@graph{$my[hp][current];${my[hp][max]}}};
	#var {my[sp][graph]} {@graph{$my[sp][current];${my[sp][max]}}}; 
        #var {my[gp1][graph]}   {@graph{$my[gp1][current];100}};
        #var {my[gp2][graph]}   {@graph{$my[gp2][current];$my[gp2][max]}};
#nop        #var {gxp_graph}        {@graph{$gxp_per;100}};
        #var {enemy[graph]}     {@graph{$enemy[hp];100}};
        #format {hp}            {%+5s} {@colscale{$my[hp][current];$my[hp][max]}};
        #format {hp_max}        {%+5s} {<128>$my[hp][max]<088>};
	#format {sp}            {%+5s} {@colscale{$my[sp][current];$my[sp][max]}};
	#format {sp_max}        {%+5s} {<128>$my[sp][max]<088>};
        #format {gp1}           {%+6s} {@colscale{$my[gp1][current];$my[gp1][max]}};
        #format {gp1_max}	{%+4s} {<128>$my[gp1][max]<088>};
        #format {gp2}           {%+3s} {@colscale{$my[gp2][current];$my[gp2][max]}};
        #format {ehealth}       {%+6s} {@colscale{$enemy[hp];100}};
#nop        #format {gxp_col}       {%+7s} {@colscale{$gxp;100}};
#nop        #format {corpses[inventory]}     {%+2s} {$corpses[inventory]};
        #format {corpses[coffin]}  {%+2s} {$corpses[coffin]};
        #format {corpses[freezer]} {%+2s} {$corpses[freezer]};
        #showme {<088>HP:$hp/$hp_max  SP:$sp/$sp_max Sat:$gp1\%    E:$ehealth\%    IC:<130>${corpses[inventory]}<088> ${sb1_cooler} Cnc: $gp2\%    Gxp: $my[g2n]\%    } {-4};
        #showme {HP:${my[hp][graph]}   SP:${my[sp][graph]}  Sat:${my[gp1][graph]} E:${enemy[graph]} CF:<130>${corpses[coffin]}<088>${sb2_freezer} <128>Deficit: <088>$mage[info][SPDeficit]} {-3};
	#showme {$mip[gline][1]  $mip[gline][2] <128>R:<088>$mip[round]} {-6}
}

#alias {corpsetrig} {
  study spellbook
}

#alias {save_guild_vars} {#class mage_vars write {.tt/3k/vars/mage.var}}

#alias {mauto} {

  #regex {%0} {{^(.+) (.+)$}}
  {
    #var _setting {&2};
    #var _value {&3};
  }
  {
    #regex {%0} {{^(.+)$}} {
      #var _setting {&2};
      #var _value {_noval};
    }
    {
      #var _setting {_noval};
      #var _value {_noval};
    }
  };


  #regex {%0} {^$} {
    #showme Usage: mauto <setting> [<value>];
    #showme Value can be omitted for settings that toggle on/off (0/1 values).;
    #foreach {*magev[auto][]} {item} {#showme Setting $item  Current value: $magev[auto][$item]}; 
  };

  #if {"$_setting"!="_noval"}
  {
    #if {"$_value"!="_noval"} {#var magev[auto][$_setting] {$_value};#showme $_setting is now set to $_value};
    #if {"$_value"=="_noval"} {
      #if {$magev[auto][$_setting]} {
        #var magev[auto][$_setting] {0};#showme $_setting is now toggled off.
      } 
      {
        #var magev[auto][$_setting] {1};#showme $_setting is now toggled on.}
    }
  }
}

#alias refm {
        #SEND !cast fabricate as dagger#dagger#dagger;
        #SEND !cast fabricate as dagger#dagger#dagger;
        #SEND !cast fabricate as dagger#dagger#dagger;
        #SEND !cast fabricate as dagger#dagger#dagger;
        #SEND !cast fabricate as item#forge#forge;

        #SEND !get dagger;
        #SEND !reforge dagger with little from edged to penetrate;
        #SEND !dispose dagger;

        #SEND !get dagger;
        #SEND !reforge dagger with little from edged to penetrate;
        #SEND !dispose dagger;

        #SEND !get dagger;
        #SEND !reforge dagger with little from edged to penetrate;
        #SEND !dispose dagger;

        #SEND !get dagger;
        #SEND !reforge dagger with little from edged to penetrate;
        #SEND !dispose dagger;

        #SEND !get forge;
        #SEND !dispose forge;
};



#class {mage} {close}
